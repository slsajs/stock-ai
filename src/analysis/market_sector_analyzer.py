"""
ÏãúÏû• Ï†ÑÏ≤¥ ÎèôÌñ• Î∞è ÏÑπÌÑ∞Î≥Ñ Î∂ÑÏÑùÍ∏∞
KOSPI, KOSDAQ ÏßÄÏàò Î∂ÑÏÑùÍ≥º ÏÑπÌÑ∞ Î°úÌÖåÏù¥ÏÖò Î∂ÑÏÑù
"""

import logging
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class MarketCondition:
    """ÏãúÏû• ÏÉÅÌô© Ï†ïÎ≥¥"""
    index_name: str
    current_value: float
    change_rate: float
    volume_ratio: float
    trend: str  # ÏÉÅÏäπ/ÌïòÎùΩ/Î≥¥Ìï©
    strength: str  # Í∞ïÏÑ∏/ÏïΩÏÑ∏/Ï§ëÎ¶Ω
    outlook: str  # Í∏çÏ†ï/Î∂ÄÏ†ï/Ï§ëÎ¶Ω

@dataclass
class SectorInfo:
    """ÏÑπÌÑ∞ Ï†ïÎ≥¥"""
    sector_name: str
    performance: float  # ÏµúÍ∑º ÏÑ±Í≥º
    momentum: float    # Î™®Î©òÌÖÄ Ï†êÏàò
    volume_change: float  # Í±∞ÎûòÎüâ Î≥ÄÌôî
    ranking: int       # ÏÑπÌÑ∞ ÏàúÏúÑ
    outlook: str       # Ï†ÑÎßù

class MarketSectorAnalyzer:
    """ÏãúÏû• Î∞è ÏÑπÌÑ∞ Î∂ÑÏÑùÍ∏∞"""
    
    def __init__(self, api_client):
        self.api_client = api_client
        
        # Ï£ºÏöî ÏßÄÏàò ÏΩîÎìú
        self.major_indices = {
            "0001": "KOSPI",
            "1001": "KOSDAQ",
            "2001": "KOSPI200"
        }
        
        # ÎåÄÌëú ÏÑπÌÑ∞Î≥Ñ Ï¢ÖÎ™© (ETFÎÇò ÎåÄÌëú Ï¢ÖÎ™©ÏúºÎ°ú ÏÑπÌÑ∞ Î∂ÑÏÑù)
        self.sector_stocks = {
            "IT/Î∞òÎèÑÏ≤¥": ["005930", "000660", "035420"],  # ÏÇºÏÑ±Ï†ÑÏûê, SKÌïòÏù¥ÎãâÏä§, ÎÑ§Ïù¥Î≤Ñ
            "Î∞îÏù¥Ïò§": ["207940", "068270", "326030"],      # ÏÇºÏÑ±Î∞îÏù¥Ïò§Î°úÏßÅÏä§, ÏÖÄÌä∏Î¶¨Ïò®, Î∞±Ïã†ÌÖåÎùºÌì®Ìã±Ïä§
            "2Ï∞®Ï†ÑÏßÄ": ["373220", "066970", "051910"],     # LGÏóêÎÑàÏßÄÏÜîÎ£®ÏÖò, ÏóòÏï§ÏóêÌîÑ, LGÌôîÌïô
            "ÏûêÎèôÏ∞®": ["005380", "012330", "000270"],      # ÌòÑÎåÄÏ∞®, ÌòÑÎåÄÎ™®ÎπÑÏä§, Í∏∞ÏïÑ
            "Ï°∞ÏÑ†": ["009540", "010140", "067250"],        # HDÌïúÍµ≠Ï°∞ÏÑ†Ìï¥Ïñë, ÏÇºÏÑ±Ï§ëÍ≥µÏóÖ, ÌòÑÎåÄÏúÑÏïÑ
            "Í∏àÏúµ": ["055550", "086790", "316140"],        # Ïã†ÌïúÏßÄÏ£º, ÌïòÎÇòÍ∏àÏúµÏßÄÏ£º, Ïö∞Î¶¨Í∏àÏúµÏßÄÏ£º
            "ÌôîÌïô": ["051910", "009150", "011170"],        # LGÌôîÌïô, ÏÇºÏÑ±Ï†ÑÍ∏∞, Î°ØÎç∞ÏºÄÎØ∏Ïπº
            "Í±¥ÏÑ§": ["000720", "028050", "006360"],        # ÌòÑÎåÄÍ±¥ÏÑ§, ÏÇºÏÑ±Î¨ºÏÇ∞, GSÍ±¥ÏÑ§
            "Ïú†ÌÜµ": ["023530", "069960", "282330"]         # Î°ØÎç∞ÏáºÌïë, ÌòÑÎåÄÎ∞±ÌôîÏ†ê, ÌòÑÎåÄÌôàÏáºÌïë
        }
        
    async def analyze_market_condition(self) -> Dict[str, MarketCondition]:
        """Ï†ÑÏ≤¥ ÏãúÏû• ÏÉÅÌô© Î∂ÑÏÑù"""
        logger.info("üìä ÏãúÏû• Ï†ÑÏ≤¥ Î∂ÑÏÑù ÏãúÏûë")
        
        market_conditions = {}
        
        for i, (index_code, index_name) in enumerate(self.major_indices.items(), 1):
            try:
                condition = await self._analyze_single_index(index_code, index_name)
                if condition:
                    market_conditions[index_code] = condition
                    
                # API Ìò∏Ï∂ú Ï†úÌïú: 0.3Ï¥à ÎåÄÍ∏∞
                await asyncio.sleep(0.3)
                logger.info(f"üìä ÏßÄÏàò Î∂ÑÏÑù ÏôÑÎ£å ({i}/{len(self.major_indices)}): {index_name}")
                
            except Exception as e:
                logger.error(f"ÏßÄÏàò Î∂ÑÏÑù Ïò§Î•ò ({index_name}): {e}")
                continue
        
        # Ï†ÑÏ≤¥ ÏãúÏû• ÏÉÅÌô© ÏöîÏïΩ
        overall_condition = self._summarize_market_condition(market_conditions)
        logger.info(f"üìà ÏãúÏû• ÏÉÅÌô© ÏöîÏïΩ: {overall_condition}")
        
        return market_conditions
    
    async def analyze_sector_rotation(self) -> List[SectorInfo]:
        """ÏÑπÌÑ∞ Î°úÌÖåÏù¥ÏÖò Î∂ÑÏÑù"""
        logger.info("üîÑ ÏÑπÌÑ∞ Î°úÌÖåÏù¥ÏÖò Î∂ÑÏÑù ÏãúÏûë")
        
        sector_performances = []
        
        # ÏÑπÌÑ∞ ÏàòÎ•º Ï†úÌïúÌïòÏó¨ API Ìò∏Ï∂ú Í∞êÏÜå
        limited_sectors = dict(list(self.sector_stocks.items())[:5])  # ÏÉÅÏúÑ 5Í∞ú ÏÑπÌÑ∞Îßå
        
        for i, (sector_name, stock_codes) in enumerate(limited_sectors.items(), 1):
            try:
                logger.info(f"üîÑ ÏÑπÌÑ∞ Î∂ÑÏÑù Ï§ë ({i}/{len(limited_sectors)}): {sector_name}")
                performance = await self._calculate_sector_performance(sector_name, stock_codes[:2])  # Ï¢ÖÎ™©ÏàòÎèÑ 2Í∞úÎ°ú Ï†úÌïú
                if performance:
                    sector_performances.append(performance)
                    
                # API Ìò∏Ï∂ú Ï†úÌïú: 0.5Ï¥à ÎåÄÍ∏∞
                await asyncio.sleep(0.5)
                
            except Exception as e:
                logger.error(f"ÏÑπÌÑ∞ Î∂ÑÏÑù Ïò§Î•ò ({sector_name}): {e}")
                continue
        
        # ÏÑ±Í≥ºÏàú Ï†ïÎ†¨
        sector_performances.sort(key=lambda x: x.performance, reverse=True)
        
        # ÏàúÏúÑ Îß§Í∏∞Í∏∞
        for i, sector in enumerate(sector_performances, 1):
            sector.ranking = i
        
        logger.info("üìä ÏÑπÌÑ∞Î≥Ñ ÏÑ±Í≥º ÏàúÏúÑ:")
        for sector in sector_performances[:5]:
            logger.info(f"  {sector.ranking}. {sector.sector_name}: {sector.performance:+.2f}% "
                      f"(Î™®Î©òÌÖÄ: {sector.momentum:.1f})")
        
        return sector_performances
    
    async def get_market_sentiment_score(self) -> float:
        """ÏãúÏû• Ïã¨Î¶¨ Ï†êÏàò Í≥ÑÏÇ∞ (0~100)"""
        try:
            market_conditions = await self.analyze_market_condition()
            sector_info = await self.analyze_sector_rotation()
            
            sentiment_score = 50  # Í∏∞Î≥∏ Ï§ëÎ¶ΩÍ∞í
            
            # ÏßÄÏàò ÏÉÅÏäπÎ•† Í∏∞Î∞ò Ï†êÏàò
            if "0001" in market_conditions:  # KOSPI
                kospi_change = market_conditions["0001"].change_rate
                if kospi_change > 1:
                    sentiment_score += 20
                elif kospi_change > 0:
                    sentiment_score += 10
                elif kospi_change < -1:
                    sentiment_score -= 20
                elif kospi_change < 0:
                    sentiment_score -= 10
            
            # ÏÑπÌÑ∞ ÏÉÅÏäπ ÎπÑÏú®
            if sector_info:
                positive_sectors = sum(1 for s in sector_info if s.performance > 0)
                sector_ratio = positive_sectors / len(sector_info)
                
                if sector_ratio > 0.7:
                    sentiment_score += 15
                elif sector_ratio > 0.5:
                    sentiment_score += 5
                elif sector_ratio < 0.3:
                    sentiment_score -= 15
                elif sector_ratio < 0.5:
                    sentiment_score -= 5
            
            return max(0, min(100, sentiment_score))
            
        except Exception as e:
            logger.error(f"ÏãúÏû• Ïã¨Î¶¨ Ï†êÏàò Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            return 50
    
    async def _analyze_single_index(self, index_code: str, index_name: str) -> Optional[MarketCondition]:
        """Í∞úÎ≥Ñ ÏßÄÏàò Î∂ÑÏÑù"""
        try:
            # ÌòÑÏû¨ ÏßÄÏàò Ï†ïÎ≥¥ Ï°∞Ìöå
            current_data = await self.api_client.get_index(index_code)
            if not current_data or current_data.get('rt_cd') != '0':
                return None
            
            output = current_data.get('output', {})
            current_value = float(output.get('bstp_nmix_prpr', 0))
            change_rate = float(output.get('bstp_nmix_prdy_ctrt', 0))
            
            # Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞Î°ú Ï∂îÏÑ∏ Î∂ÑÏÑù
            trend_analysis = await self._analyze_index_trend(index_code)
            
            # Í±∞ÎûòÎüâ Î∂ÑÏÑù
            volume_ratio = await self._calculate_index_volume_ratio(index_code)
            
            # Í∞ïÎèÑ Î∞è Ï†ÑÎßù ÌåêÎã®
            strength = self._determine_strength(change_rate, trend_analysis)
            trend = self._determine_trend(change_rate, trend_analysis)
            outlook = self._determine_outlook(change_rate, trend_analysis, volume_ratio)
            
            return MarketCondition(
                index_name=index_name,
                current_value=current_value,
                change_rate=change_rate,
                volume_ratio=volume_ratio,
                trend=trend,
                strength=strength,
                outlook=outlook
            )
            
        except Exception as e:
            logger.error(f"ÏßÄÏàò Î∂ÑÏÑù Ïò§Î•ò ({index_name}): {e}")
            return None
    
    async def _analyze_index_trend(self, index_code: str) -> Dict[str, float]:
        """ÏßÄÏàò Ï∂îÏÑ∏ Î∂ÑÏÑù"""
        try:
            # ÏùºÎ¥â Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (ÏµúÍ∑º 30Ïùº)
            end_date = datetime.now().strftime("%Y%m%d")
            start_date = (datetime.now() - timedelta(days=30)).strftime("%Y%m%d")
            
            # Ïã§Ï†úÎ°úÎäî ÏßÄÏàò Ï∞®Ìä∏ APIÍ∞Ä ÌïÑÏöîÌïòÏßÄÎßå, Ïó¨Í∏∞ÏÑúÎäî Ï∂îÏ†ïÍ∞í ÏÇ¨Ïö©
            return {
                "short_term_trend": 0.5,  # Îã®Í∏∞ Ï∂îÏÑ∏ (0~1)
                "medium_term_trend": 0.6,  # Ï§ëÍ∏∞ Ï∂îÏÑ∏
                "volatility": 0.4          # Î≥ÄÎèôÏÑ± (0~1)
            }
            
        except Exception as e:
            logger.error(f"ÏßÄÏàò Ï∂îÏÑ∏ Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return {"short_term_trend": 0.5, "medium_term_trend": 0.5, "volatility": 0.5}
    
    async def _calculate_index_volume_ratio(self, index_code: str) -> float:
        """ÏßÄÏàò Í±∞ÎûòÎüâ ÎπÑÏú® Í≥ÑÏÇ∞"""
        try:
            # Ïã§Ï†úÎ°úÎäî ÏãúÏû• Ï†ÑÏ≤¥ Í±∞ÎûòÎüâ APIÍ∞Ä ÌïÑÏöî
            # Ïó¨Í∏∞ÏÑúÎäî Ï∂îÏ†ïÍ∞í Î∞òÌôò
            return 1.2  # ÌèâÍ∑† ÎåÄÎπÑ 1.2Î∞∞
        except:
            return 1.0
    
    async def _calculate_sector_performance(self, sector_name: str, stock_codes: List[str]) -> Optional[SectorInfo]:
        """ÏÑπÌÑ∞ ÏÑ±Í≥º Í≥ÑÏÇ∞"""
        try:
            total_performance = 0
            total_momentum = 0
            total_volume_change = 0
            valid_stocks = 0
            
            for stock_code in stock_codes:
                try:
                    # Í∞úÎ≥Ñ Ï£ºÏãù ÏÑ±Í≥º Î∂ÑÏÑù
                    stock_performance = await self._analyze_stock_performance(stock_code)
                    if stock_performance:
                        total_performance += stock_performance['performance']
                        total_momentum += stock_performance['momentum']
                        total_volume_change += stock_performance['volume_change']
                        valid_stocks += 1
                        
                    await asyncio.sleep(0.3)
                    
                except Exception:
                    continue
            
            if valid_stocks == 0:
                return None
            
            # ÌèâÍ∑† Í≥ÑÏÇ∞
            avg_performance = total_performance / valid_stocks
            avg_momentum = total_momentum / valid_stocks
            avg_volume_change = total_volume_change / valid_stocks
            
            # Ï†ÑÎßù Í≤∞Ï†ï
            if avg_performance > 3 and avg_momentum > 60:
                outlook = "Í∏çÏ†ï"
            elif avg_performance < -3 or avg_momentum < 40:
                outlook = "Î∂ÄÏ†ï"
            else:
                outlook = "Ï§ëÎ¶Ω"
            
            return SectorInfo(
                sector_name=sector_name,
                performance=avg_performance,
                momentum=avg_momentum,
                volume_change=avg_volume_change,
                ranking=0,  # ÎÇòÏ§ëÏóê ÏÑ§Ï†ï
                outlook=outlook
            )
            
        except Exception as e:
            logger.error(f"ÏÑπÌÑ∞ ÏÑ±Í≥º Í≥ÑÏÇ∞ Ïò§Î•ò ({sector_name}): {e}")
            return None
    
    async def _analyze_stock_performance(self, stock_code: str) -> Optional[Dict[str, float]]:
        """Í∞úÎ≥Ñ Ï£ºÏãù ÏÑ±Í≥º Î∂ÑÏÑù"""
        try:
            # ÌòÑÏû¨Í∞Ä Ï°∞Ìöå
            current_data = await self.api_client.get_current_price(stock_code)
            if not current_data or current_data.get('rt_cd') != '0':
                return None
            
            output = current_data.get('output', {})
            current_price = int(output.get('stck_prpr', 0))
            change_rate = float(output.get('prdy_ctrt', 0))
            volume = int(output.get('acml_vol', 0))
            
            # Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞Î°ú Î™®Î©òÌÖÄ Í≥ÑÏÇ∞ (Í∞ÑÎã® Î≤ÑÏ†Ñ)
            momentum = 50 + (change_rate * 2)  # Í∞ÑÎã®Ìïú Î™®Î©òÌÖÄ Í≥ÑÏÇ∞
            momentum = max(0, min(100, momentum))
            
            # Í±∞ÎûòÎüâ Î≥ÄÌôîÏú® (ÏûÑÏùòÍ∞í, Ïã§Ï†úÎ°úÎäî Í≥ºÍ±∞ ÌèâÍ∑†Í≥º ÎπÑÍµê ÌïÑÏöî)
            volume_change = 1.0 + (change_rate / 100)
            
            return {
                'performance': change_rate,
                'momentum': momentum,
                'volume_change': volume_change
            }
            
        except Exception:
            return None
    
    def _determine_strength(self, change_rate: float, trend_analysis: Dict) -> str:
        """ÏãúÏû• Í∞ïÎèÑ ÌåêÎã®"""
        if change_rate > 1.5 and trend_analysis.get('short_term_trend', 0.5) > 0.6:
            return "Í∞ïÏÑ∏"
        elif change_rate < -1.5 and trend_analysis.get('short_term_trend', 0.5) < 0.4:
            return "ÏïΩÏÑ∏"
        else:
            return "Ï§ëÎ¶Ω"
    
    def _determine_trend(self, change_rate: float, trend_analysis: Dict) -> str:
        """Ï∂îÏÑ∏ ÌåêÎã®"""
        if change_rate > 0.5:
            return "ÏÉÅÏäπ"
        elif change_rate < -0.5:
            return "ÌïòÎùΩ"
        else:
            return "Î≥¥Ìï©"
    
    def _determine_outlook(self, change_rate: float, trend_analysis: Dict, volume_ratio: float) -> str:
        """Ï†ÑÎßù ÌåêÎã®"""
        score = 0
        
        if change_rate > 0:
            score += 1
        if trend_analysis.get('short_term_trend', 0.5) > 0.6:
            score += 1
        if volume_ratio > 1.2:
            score += 1
        
        if score >= 2:
            return "Í∏çÏ†ï"
        elif score <= 0:
            return "Î∂ÄÏ†ï"
        else:
            return "Ï§ëÎ¶Ω"
    
    def _summarize_market_condition(self, conditions: Dict[str, MarketCondition]) -> str:
        """ÏãúÏû• ÏÉÅÌô© Ï¢ÖÌï© ÌåêÎã®"""
        if not conditions:
            return "Î∂ÑÏÑù Î∂àÍ∞Ä"
        
        positive_count = sum(1 for c in conditions.values() if c.change_rate > 0)
        total_count = len(conditions)
        
        if positive_count >= total_count * 0.8:
            return "Ï†ÑÎ∞òÏ†Å ÏÉÅÏäπÏÑ∏"
        elif positive_count >= total_count * 0.6:
            return "ÏïΩÍ∞Ñ ÏÉÅÏäπÏÑ∏"
        elif positive_count >= total_count * 0.4:
            return "ÌòºÏ°∞ÏÑ∏"
        else:
            return "Ï†ÑÎ∞òÏ†Å ÌïòÎùΩÏÑ∏"
    
    async def get_favorable_sectors(self, top_n: int = 3) -> List[str]:
        """Ïú†Î¶¨Ìïú ÏÑπÌÑ∞ Ï∂îÏ≤ú"""
        try:
            sector_info = await self.analyze_sector_rotation()
            
            # ÏÑ±Í≥ºÏôÄ Î™®Î©òÌÖÄÏùÑ Ï¢ÖÌï©ÌïòÏó¨ Ï†êÏàò Í≥ÑÏÇ∞
            for sector in sector_info:
                sector.combined_score = (sector.performance * 0.6) + (sector.momentum * 0.4)
            
            # Ï†êÏàòÏàú Ï†ïÎ†¨
            sector_info.sort(key=lambda x: getattr(x, 'combined_score', 0), reverse=True)
            
            return [sector.sector_name for sector in sector_info[:top_n]]
            
        except Exception as e:
            logger.error(f"Ïú†Î¶¨Ìïú ÏÑπÌÑ∞ Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return ["IT/Î∞òÎèÑÏ≤¥", "Î∞îÏù¥Ïò§", "2Ï∞®Ï†ÑÏßÄ"]  # Í∏∞Î≥∏Í∞í